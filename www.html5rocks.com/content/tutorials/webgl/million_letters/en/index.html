{% extends "sample.html" %}

{% block headauthor %}Ilmari Heikkinen <ilmari@google.com>{% endblock %}
{% block pageauthor %}{% profilelinks ilmariheikkinen %}{% endblock %}
{% block headtitle %}Animating a Million Letters Using Three.js{% endblock %}
{% block pagetitle %}Animating a Million Letters Using Three.js{% endblock %}
{% block head %}

{% endblock %}
{% block pagebreadcrumb %}Animating a Million Letters Using Three.js{% endblock %}
{% block date %}January 30, 2012{% endblock %}
{% block updated %}{% endblock %}
{% block onload %}{% endblock %}

{% block browsersupport %}
<span class="opera supported"></span>
<span class="ie"></span>
<span class="safari supported"></span>
<span class="ff supported"></span>
<span class="chrome supported"></span>
{% endblock %}

{% block iscompatible %}
  return !!Modernizr.webgl
{% endblock %}

{% block content %}

<p style="text-align: center;"><img src="million_letters.jpg"><br>

<a href="million_letters.html">Animated letters demo</a>

<h2 id="toc-intro">Introduction</h2>
<p>My goal in this article is to draw a million animated letters on the screen at a smooth framerate. This task should be quite possible with modern GPUs. Each letter consists of two textured triangles, so we're only talking about two million triangles per frame. 

<p>If you're coming from a traditional JavaScript animation background, this all sounds like madness. Two million triangles updated every frame is definitely not something you would like to do with JavaScript today. But thankfully we have WebGL, which lets us tap into the awesome power of modern GPUs. And two million animated triangles is quite doable with a modern GPU and some shader magic.

<h2 id="toc-efficientwebgl">Writing efficient WebGL code</h2>
<p>Writing efficient WebGL code requires a specific mindset. The basic idea is to collect as many operations as possible into a single draw call, as changing the WebGL state machine state and doing WebGL calls is relatively expensive. If you want to draw more than a couple thousand objects at once, you need to adopt a quite different strategy for drawing.

<p>The usual way of drawing with WebGL is to set up your uniforms, buffers and shaders for each object, followed by a call to draw the object. Unless your object is very complex, the time taken in this way of drawing is dominated by the state setup. To draw in a fast way, you can either do some buffer editing in JavaScript, followed by re-uploading the buffer and the draw call. If you need to go even faster, you can push more computation to the shaders.

<p>I'm going to be using the Three.js library for writing this demo. Three.js abstracts away all the tedious boilerplate from writing WebGL code. Instead of writing a hundred lines of WebGL state setup and error handling, you only need to write a couple lines of code using Three.js. And you can tap into the WebGL shader system from Three.js quite easily.

<h3 id="toc-efficientwebgl-example">Geometry bundling example</h3>
<p>Instead of drawing one object at a time:
<pre class="prettyprint">
for (var i=0; i&lt;objects.length; i++) {
  scene.add(createNewObject(objects[i]));
}
</pre>

<p>Do it by bundling up the objects into a single geometry:
<pre class="prettyprint">
var geo = new THREE.Geometry();
for (var i=0; i&lt;objects.length; i++) {
  addObjectToGeometry(geo, objects[i]);
}
scene.add(new THREE.Mesh(geo, material));
</pre>


<h2 id="toc-setup">Setting up the geometry and textures</h2>
<p>To start I'm going to create a texture with the letter bitmaps on it. I'm using the 2D canvas for this. The resulting texture has all the letters I want to draw. Then I'm going to create a buffer with texture coordinates to the letter sprite sheet. While this is an easy and straightforward method of setting up the letters, it’s a bit wasteful as it uses two floats per vertex for the texcoords. A shorter way would be to pack the letter index and corner index into one number and convert that back to texture coordinates in the vertex shader.

<p>Building the letter texture using Canvas 2D:
<pre class="prettyprint">
var fontSize = 16;
var lettersPerSide = 16; // 16*16 = 256, all 8-bit characters
var c = document.createElement('canvas');
c.width = c.height = fontSize*lettersPerSide;
var ctx = c.getContext('2d');
ctx.font = fontSize+'px Monospace';

var yOffset = -0.25; // magic number for aligning the letters on rows

// draw all the letters to the canvas
for (var i=0,y=0; y&lt;lettersPerSide; y++) {
  for (var x=0; x&lt;lettersPerSide; x++,i++) {
    var ch = String.fromCharCode(i);
    ctx.fillText(ch, x*fontSize, yOffset*fontSize+(y+1)*fontSize);
  }
}

// create texture from the letter map
var tex = new THREE.Texture(c);
tex.needsUpdate = true;
</pre>

<p>I also upload the triangle array to the GPU. These vertices are used by the vertex shader to put the letters on the screen. The vertices are set to the letter positions in the text so that if you render the triangle array as-is, you get a basic layout rendering of the text.

<p>Creating the geometry for the book:
<pre class="prettyprint">
var geo = new THREE.Geometry();

var v3 = function(x,y,z) {
  return new THREE.Vertex(new THREE.Vector3(x,y,z));
};

var i=0, x=0, line=0;
for (i=0; i<BOOK.length; i++) {
  var code = BOOK.charCodeAt(i); // character code for current letter
  if (code > lettersPerSide * lettersPerSide) {
    code = 0; // clamp character codes to letter map size
  }
  var cx = code % lettersPerSide; // x-index of the letter in map
  var cy = Math.floor(code / lettersPerSide); // y-index of the letter in map

  // add letter vertices to the geometry
  var v,t;
  geo.vertices.push(
    v3( x*1.1+0.05, line*1.1+0.05, 0 ),
    v3( x*1.1+1.05, line*1.1+0.05, 0 ),
    v3( x*1.1+1.05, line*1.1+1.05, 0 ),
    v3( x*1.1+0.05, line*1.1+1.05, 0 )
  );
  // create face for the letter
  var face = new THREE.Face4(i*4+0, i*4+1, i*4+2, i*4+3);
  geo.faces.push(face);

  // compute texture coords for letters
  var tx=cx/lettersPerSide, ty=cy/lettersPerSide, off=1/lettersPerSide;
  var sz = lettersPerSide*fontSize;
  geo.faceVertexUvs[0].push([
    new THREE.UV( tx, ty+off ),
    new THREE.UV( tx+off, ty+off ),
    new THREE.UV( tx+off, ty ),
    new THREE.UV( tx, ty )
  ]);

  // move to line below on linefeed and move cursor to start of line
  // otherwise move cursor to the right
  if (code == 10) {
    line--;
    x=0;
  } else {
    x++;
  }
}
</pre>


<h2 id="toc-shader">Vertex shader for animating the letters</h2>
<p>With a simple vertex shader, I get a flat view of the text. Nothing fancy. Runs well, but if I want to animate it, I need to do the animation in Javascript. And JavaScript is kinda slow for animating the six million vertices involved, especially if you want to do it on every frame. Maybe there is there a faster way.

<p>Why yes, we can do procedural animation. What that means is that we do all our position and rotation math in the vertex shader. Now I don't need to run any JavaScript to update the positions of the vertices. The vertex shader runs very fast and I get a smooth framerate even with a million triangles being individually animated every frame. To address the individual triangles, I round down the vertex coordinates so that all four points of a letter quad map to a single unique coordinate. Now I can use this coordinate to set the animation parameters for the letter in question.

<p>Simple vertex shader (with explanations)
<pre class="prettyprint">
varying float vUv;

void main() {
  // modelViewMatrix, position and projectionMatrix are magical
  // attributes that Three.js defines for us

  // transform current vertex by the modelViewMatrix
  // (bundled model world position & camera world position matrix)
  vec4 mvPosition = modelViewMatrix * position;

  // project camera-space vertex to screen coordinates
  // using the camera's projection matrix
  vec4 p = projectionMatrix * mvPosition;

  // uv is another magical attribute from Three.js
  // we're passing it to the fragment shader unchanged
  vUv = uv;

  gl_Position = p;
}
</pre>

<p>Animated vertex shader 
<pre class="prettyprint">
uniform float uTime;
uniform float uEffectAmount;

varying float vZ;
varying vec2 vUv;

// Returns the mat3 rotation matrix for given angle and axis.
mat3 rotateAngleAxisMatrix(float angle, vec3 axis) {
  float c = cos(angle);
  float s = sin(angle);
  float t = 1.0 - c;
  axis = normalize(axis);
  float x = axis.x, y = axis.y, z = axis.z;
  return mat3(
    t*x*x + c,    t*x*y + s*z,  t*x*z - s*y,
    t*x*y - s*z,  t*y*y + c,    t*y*z + s*x,
    t*x*z + s*y,  t*y*z - s*x,  t*z*z + c
  );
}

// Rotates a vec3 over the given axis by the given angle and
// returns the rotated vector.
vec3 rotateAngleAxis(float angle, vec3 axis, vec3 v) {
  return rotateAngleAxisMatrix(angle, axis) * v;
}

void main() {
  // find letter index in book text (assuming 80-character max line length)
  float idx = floor(position.y/1.1)*80.0 + floor(position.x/1.1);
  // round down the vertex coords to find bottom-left corner point of letter
  vec3 corner = vec3(floor(position.x/1.1)*1.1, floor(position.y/1.1)*1.1, 0.0);
  // find midpoint of letter
  vec3 mid = corner + vec3(0.5, 0.5, 0.0);
  // rotate letter around its midpoint by an angle and axis dependent on
  // the letter's index and the current time
  vec3 rpos = rotateAngleAxis(idx+uTime, 
    vec3(mod(idx,16.0), -8.0+mod(idx,15.0), 1.0), position - mid) + mid;

  // uEffectAmount controls the amount of animation applied to the letter.
  // uEffectAmount ranges from 0.0 to 1.0.
  float effectAmount = uEffectAmount;

  vec4 fpos = vec4( mix(position,rpos,effectAmount), 1.0 );
  fpos.x += -35.0;
  // apply spinning motion to individual letters
  fpos.z += ((sin(idx+uTime*2.0)))*4.2*effectAmount;
  fpos.y += ((cos(idx+uTime*2.0)))*4.2*effectAmount;

  vec4 mvPosition = modelViewMatrix * fpos;
  // apply wavy motion to the entire text
  mvPosition.y += 10.0*sin(uTime*0.5+mvPosition.x/25.0)*effectAmount;
  mvPosition.x -= 10.0*cos(uTime*0.5+mvPosition.y/25.0)*effectAmount;

  vec4 p = projectionMatrix * mvPosition;

  // pass texture coordinates and vertex z-coordinate to fragment shader
  vUv = uv;
  vZ = p.z;

  // send final vertex position to WebGL
  gl_Position = p;
}
</pre>

<p>To use the vertex shader, I use a THREE.MeshShaderMaterial, a material type that lets you use custom shaders and specify uniforms for them. Three.js provides some pre-built attributes for the shader, such as position, uv, modelViewMatrix and perspectiveMatrix. What this means is that it's usually easier to write shaders for Three.js than with raw WebGL.

<p>Here's the MeshShaderMaterial example:
<pre class="prettyprint">
// set up uniforms for the shader
var uniforms = {
  // pass the letter map texture as a built-in uniform
  map : { type: "t", value: 1, texture: tex },
  // current time
  uTime : { type: "f", value: 1.0 },
  // amount of animation to show
  uEffectAmount : { type: "f", value: 0.0 }
};
  
var shaderMaterial = new THREE.ShaderMaterial({
  uniforms : uniforms,

  // I have my shaders inside HTML elements like
  // &lt;script type="text/x-glsl-vert">... shaderSource ... &lt;script>
  vertexShader : document.querySelector('#vertex').textContent,

  // The fragment shader is a bit special as well, drawing a rotating
  // rainbow gradient.
  fragmentShader : document.querySelector('#fragment').textContent
});

// set depthTest to false so that the letters don't occlude each other
shaderMaterial.depthTest = false;
</pre>

<p>On animation frames, I update the shader uniforms:
<pre class="prettyprint">
// Controlling the uniforms through a control object
// The reason I'm not controlling the uniforms directly is to 
// have different names and value ranges for the uniforms and the controls
var controller = {
  effectAmount: 0
};

// I'm using DAT.GUI to do a quick & easy GUI for the demo
var gui = new dat.GUI();
gui.add(controller, 'effectAmount', 0, 100);

var animate = function(t) {
  uniforms.uTime.value += 0.05;
  uniforms.uEffectAmount.value = controller.effectAmount/100;
  bookModel.position.y += 0.03;

  renderer.render(scene, camera);
  requestAnimationFrame(animate, renderer.domElement);
};
animate(+new Date);
</pre>

And there you have it, shader-based animation. It looks pretty complex but the only thing it really does is moves the letters around in a way that depends on the letter's index. If performance wasn't a concern you would have this logic running in JavaScript. However, at tens of thousands of objects, JavaScript stops being a viable solution.

<h2 id="toc-concerns">Remaining concerns</h2>
<p>The only problem now is that JavaScript doesn’t know about the particle positions. If you really need to know where your particles are, you could duplicate the vertex shader logic in JavaScript and re-calculate the vertex positions using a web worker every time you need the positions. That way your rendering thread doesn’t have to wait for the math and you can continue animating at a smooth frame rate.

<p>For more controllable animation, you could use render-to-texture functionality to tween between the JavaScript-provided positions and the current positions. First render the current positions to the texture, then tween from the JS array towards these positions, updating the texture on each frame. The nice thing about this is that you can update a small fraction of the JS positions per frame and still continue animating all the letters every frame with the vertex shader tweening the positions. 

  <h2 id="toc-references">References</h2>
  <ul>
    <li><a href="https://github.com/mrdoob/three.js/">Three.js</a></li>
    <li><a href="http://www.gutenberg.org/ebooks/5200">Metamorphosis by Franz Kafka on Project Gutenberg</a></li>
  </ul>

{% endblock %}
